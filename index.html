!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Box Battles - 3D Fighting Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
        }
        
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 10;
        }
        
        .screen.active {
            display: flex;
        }
        
        #startScreen {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .title {
            font-size: 72px;
            font-weight: bold;
            text-shadow: 4px 4px 8px rgba(0,0,0,0.5);
            margin-bottom: 20px;
            letter-spacing: 4px;
        }
        
        .subtitle {
            font-size: 24px;
            margin-bottom: 40px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        .btn {
            padding: 20px 60px;
            font-size: 28px;
            font-weight: bold;
            background: linear-gradient(45deg, #ff6b6b, #ee5a6f);
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            box-shadow: 0 8px 16px rgba(0,0,0,0.3);
            transition: transform 0.2s;
            margin: 10px;
        }
        
        .btn:hover {
            transform: scale(1.1);
        }
        
        .controls-box {
            margin-top: 60px;
            text-align: center;
            font-size: 18px;
            background: rgba(0,0,0,0.3);
            padding: 20px 40px;
            border-radius: 10px;
        }
        
        .controls-title {
            font-weight: bold;
            margin-bottom: 15px;
            font-size: 22px;
        }
        
        #hud {
            position: absolute;
            top: 20px;
            left: 0;
            right: 0;
            display: none;
            justify-content: space-around;
            padding: 0 40px;
            font-size: 24px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px black;
            z-index: 5;
        }
        
        #hud.active {
            display: flex;
        }
        
        .health-container {
            text-align: center;
        }
        
        .health-bar-bg {
            background: #333;
            padding: 5px 10px;
            border-radius: 5px;
            margin-top: 5px;
        }
        
        .health-bar {
            height: 20px;
            transition: width 0.3s;
        }
        
        #controlsInfo {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            display: none;
            z-index: 5;
        }
        
        #controlsInfo.active {
            display: block;
        }
        
        #winnerScreen {
            background: rgba(0,0,0,0.9);
            color: white;
        }
        
        .winner-text {
            font-size: 48px;
            font-weight: bold;
            margin-bottom: 30px;
        }
        
        #multiplayerScreen {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }
        
        .input-group {
            margin: 20px 0;
        }
        
        .input-group input {
            padding: 15px 30px;
            font-size: 20px;
            border: none;
            border-radius: 10px;
            margin: 10px;
            width: 300px;
        }
        
        .peer-id-display {
            background: rgba(0,0,0,0.3);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="startScreen" class="screen active">
        <h1 class="title">BOX BATTLES</h1>
        <p class="subtitle">Fight inside the arena!</p>
        <button class="btn" onclick="gameController.showModeSelect()">PLAY LOCAL</button>
        <button class="btn" onclick="gameController.showMultiplayerScreen()">ONLINE MULTIPLAYER</button>
        <button class="btn" onclick="gameController.startGame('bot')">PLAY VS BOT</button>
        <div class="controls-box">
            <div class="controls-title">CONTROLS</div>
            <div style="margin-bottom: 10px;">
                <span style="color: #ff6b6b;">RED FIGHTER:</span> WASD = Move, Q = Jump, E = Attack
            </div>
            <div>
                <span style="color: #6b9eff;">BLUE FIGHTER:</span> Arrows = Move, Shift = Jump, Enter = Attack
            </div>
        </div>
    </div>
    
    <div id="multiplayerScreen" class="screen">
        <h1 class="title">ONLINE MULTIPLAYER</h1>
        <div class="peer-id-display">
            <div>Your ID: <span id="yourPeerId">Connecting...</span></div>
        </div>
        <div class="input-group">
            <input type="text" id="peerIdInput" placeholder="Enter opponent's ID">
            <button class="btn" onclick="gameController.connectToPeer()">CONNECT</button>
        </div>
        <button class="btn" onclick="gameController.showStartScreen()">BACK</button>
        <div style="margin-top: 30px; background: rgba(0,0,0,0.3); padding: 20px; border-radius: 10px; max-width: 500px;">
            <p>Share your ID with a friend to play together!</p>
            <p style="margin-top: 10px;">Once connected, Player 1 hosts and both can play.</p>
        </div>
    </div>
    
    <div id="hud">
        <div class="health-container">
            <div style="color: #ff0000;">RED FIGHTER</div>
            <div class="health-bar-bg">
                <div id="health1" class="health-bar" style="background: #ff0000; width: 200px;"></div>
            </div>
        </div>
        <div class="health-container">
            <div style="color: #0000ff;">BLUE FIGHTER</div>
            <div class="health-bar-bg">
                <div id="health2" class="health-bar" style="background: #0000ff; width: 200px;"></div>
            </div>
        </div>
    </div>
    
    <div id="controlsInfo">
        <div style="font-weight: bold; margin-bottom: 10px;">CONTROLS</div>
        <div><span style="color: #ff0000;">RED:</span> WASD = Move, Q = Jump, E = Attack</div>
        <div><span style="color: #0000ff;">BLUE:</span> Arrows = Move, Shift = Jump, Enter = Attack</div>
    </div>
    
    <div id="winnerScreen" class="screen">
        <div class="winner-text" id="winnerText"></div>
        <button class="btn" onclick="gameController.resetGame()">PLAY AGAIN</button>
        <button class="btn" onclick="gameController.showStartScreen()">MAIN MENU</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        var gameController = (function() {
            var scene, camera, renderer;
            var player1, player2;
            var gameMode = null;
            var peer, conn;
            var isHost = false;
            var myPlayerNum = 1;
            var animationId = null;
            
            var gameState = {
                player1: { health: 100, jumping: false, velocity: { x: 0, y: 0, z: 0 }, position: { x: -4, y: 1, z: 0 } },
                player2: { health: 100, jumping: false, velocity: { x: 0, y: 0, z: 0 }, position: { x: 4, y: 1, z: 0 } }
            };
            
            var keys = {};
            var moveSpeed = 0.15;
            var jumpPower = 0.3;
            var gravity = 0.015;
            var attackRange = 2.5;
            var attackCooldown = { p1: 0, p2: 0 };
            
            function initPeer() {
                peer = new Peer();
                
                peer.on('open', function(id) {
                    document.getElementById('yourPeerId').textContent = id;
                });
                
                peer.on('connection', function(connection) {
                    conn = connection;
                    setupConnection();
                    isHost = true;
                    myPlayerNum = 1;
                });
            }
            
            function connectToPeer() {
                var peerId = document.getElementById('peerIdInput').value.trim();
                if (!peerId) return;
                
                conn = peer.connect(peerId);
                setupConnection();
                isHost = false;
                myPlayerNum = 2;
            }
            
            function setupConnection() {
                conn.on('open', function() {
                    startGame('online');
                });
                
                conn.on('data', function(data) {
                    if (data.type && data.type === 'gameState') {
                        if (!isHost) {
                            gameState.player1 = data.state.player1;
                            gameState.player2 = data.state.player2;
                            updateVisuals();
                        }
                    } else if (data.type && data.type === 'input') {
                        handleRemoteInput(data.keys);
                    }
                });
            }
            
            function sendGameState() {
                if (conn && conn.open && isHost) {
                    conn.send({ type: 'gameState', state: gameState });
                }
            }
            
            function sendInput() {
                if (conn && conn.open && !isHost) {
                    conn.send({ type: 'input', keys: keys });
                }
            }
            
            function handleRemoteInput(remoteKeys) {
                if (isHost) {
                    processPlayerInput(2, remoteKeys);
                }
            }
            
            function showStartScreen() {
                document.getElementById('startScreen').classList.add('active');
                document.getElementById('multiplayerScreen').classList.remove('active');
                document.getElementById('winnerScreen').classList.remove('active');
                document.getElementById('hud').classList.remove('active');
                document.getElementById('controlsInfo').classList.remove('active');
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
            }
            
            function showModeSelect() {
                startGame('local');
            }
            
            function showMultiplayerScreen() {
                document.getElementById('startScreen').classList.remove('active');
                document.getElementById('multiplayerScreen').classList.add('active');
                if (!peer) initPeer();
            }
            
            function initThreeJS() {
                var canvas = document.getElementById('gameCanvas');
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x87ceeb);
                
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 8, 15);
                camera.lookAt(0, 0, 0);
                
                renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                
                var ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);
                
                var directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 10, 5);
                directionalLight.castShadow = true;
                scene.add(directionalLight);
                
                var arenaSize = 12;
                var wallThickness = 0.5;
                var wallHeight = 6;
                
                var floorGeometry = new THREE.BoxGeometry(arenaSize, 0.5, arenaSize);
                var floorMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
                var floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.position.y = -0.25;
                floor.receiveShadow = true;
                scene.add(floor);
                
                var wallMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x8b4513, 
                    transparent: true, 
                    opacity: 0.4,
                    side: THREE.DoubleSide
                });
                
                var backWall = new THREE.Mesh(
                    new THREE.BoxGeometry(arenaSize, wallHeight, wallThickness),
                    wallMaterial
                );
                backWall.position.set(0, wallHeight/2, -arenaSize/2);
                scene.add(backWall);
                
                var frontWall = new THREE.Mesh(
                    new THREE.BoxGeometry(arenaSize, wallHeight, wallThickness),
                    wallMaterial
                );
                frontWall.position.set(0, wallHeight/2, arenaSize/2);
                scene.add(frontWall);
                
                var leftWall = new THREE.Mesh(
                    new THREE.BoxGeometry(wallThickness, wallHeight, arenaSize),
                    wallMaterial
                );
                leftWall.position.set(-arenaSize/2, wallHeight/2, 0);
                scene.add(leftWall);
                
                var rightWall = new THREE.Mesh(
                    new THREE.BoxGeometry(wallThickness, wallHeight, arenaSize),
                    wallMaterial
                );
                rightWall.position.set(arenaSize/2, wallHeight/2, 0);
                scene.add(rightWall);
                
                var player1Geometry = new THREE.BoxGeometry(1, 2, 1);
                var player1Material = new THREE.MeshStandardMaterial({ color: 0xff0000 });
                player1 = new THREE.Mesh(player1Geometry, player1Material);
                player1.position.set(-4, 1, 0);
                player1.castShadow = true;
                scene.add(player1);
                
                var player2Geometry = new THREE.BoxGeometry(1, 2, 1);
                var player2Material = new THREE.MeshStandardMaterial({ color: 0x0000ff });
                player2 = new THREE.Mesh(player2Geometry, player2Material);
                player2.position.set(4, 1, 0);
                player2.castShadow = true;
                scene.add(player2);
                
                window.addEventListener('resize', function() {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
            
            function startGame(mode) {
                gameMode = mode;
                document.getElementById('startScreen').classList.remove('active');
                document.getElementById('multiplayerScreen').classList.remove('active');
                document.getElementById('hud').classList.add('active');
                document.getElementById('controlsInfo').classList.add('active');
                
                gameState.player1.health = 100;
                gameState.player2.health = 100;
                gameState.player1.position = { x: -4, y: 1, z: 0 };
                gameState.player2.position = { x: 4, y: 1, z: 0 };
                gameState.player1.velocity = { x: 0, y: 0, z: 0 };
                gameState.player2.velocity = { x: 0, y: 0, z: 0 };
                gameState.player1.jumping = false;
                gameState.player2.jumping = false;
                attackCooldown.p1 = 0;
                attackCooldown.p2 = 0;
                
                if (!renderer) {
                    initThreeJS();
                }
                
                updateHealthBars();
                animate();
            }
            
            function updateHealthBars() {
                document.getElementById('health1').style.width = (gameState.player1.health * 2) + 'px';
                document.getElementById('health2').style.width = (gameState.player2.health * 2) + 'px';
            }
            
            function updateVisuals() {
                if (player1 && player2) {
                    player1.position.set(gameState.player1.position.x, gameState.player1.position.y, gameState.player1.position.z);
                    player2.position.set(gameState.player2.position.x, gameState.player2.position.y, gameState.player2.position.z);
                    updateHealthBars();
                }
            }
            
            function createAttackEffect(position, color) {
                var effect = new THREE.Mesh(
                    new THREE.SphereGeometry(0.5, 16, 16),
                    new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.7 })
                );
                effect.position.copy(position);
                scene.add(effect);
                
                setTimeout(function() {
                    scene.remove(effect);
                }, 200);
            }
            
            function botAI() {
                var botKeys = {};
                var p1Pos = gameState.player1.position;
                var p2Pos = gameState.player2.position;
                var distance = Math.sqrt(
                    Math.pow(p1Pos.x - p2Pos.x, 2) + 
                    Math.pow(p1Pos.z - p2Pos.z, 2)
                );
                
                if (distance > 3) {
                    if (p1Pos.x < p2Pos.x) {
                        botKeys['arrowleft'] = true;
                    } else {
                        botKeys['arrowright'] = true;
                    }
                    
                    if (p1Pos.z < p2Pos.z) {
                        botKeys['arrowup'] = true;
                    } else {
                        botKeys['arrowdown'] = true;
                    }
                }
                
                if (distance < attackRange && Math.random() > 0.95) {
                    botKeys['enter'] = true;
                }
                
                if (Math.random() > 0.98 && !gameState.player2.jumping) {
                    botKeys['shift'] = true;
                }
                
                return botKeys;
            }
            
            function processPlayerInput(playerNum, inputKeys) {
                var state = (playerNum === 1) ? gameState.player1 : gameState.player2;
                var opponent = (playerNum === 1) ? gameState.player2 : gameState.player1;
                var controls = (playerNum === 1) ? 
                    { up: 'w', down: 's', left: 'a', right: 'd', jump: 'q', attack: 'e' } :
                    { up: 'arrowup', down: 'arrowdown', left: 'arrowleft', right: 'arrowright', jump: 'shift', attack: 'enter' };
                var cooldown = (playerNum === 1) ? 'p1' : 'p2';
                
                if (inputKeys[controls.up]) {
                    state.velocity.z = -moveSpeed;
                } else if (inputKeys[controls.down]) {
                    state.velocity.z = moveSpeed;
                } else {
                    state.velocity.z = 0;
                }
                
                if (inputKeys[controls.left]) {
                    state.velocity.x = -moveSpeed;
                } else if (inputKeys[controls.right]) {
                    state.velocity.x = moveSpeed;
                } else {
                    state.velocity.x = 0;
                }
                
                if (inputKeys[controls.jump] && !state.jumping) {
                    state.velocity.y = jumpPower;
                    state.jumping = true;
                }
                
                if (inputKeys[controls.attack] && attackCooldown[cooldown] <= 0) {
                    var distance = Math.sqrt(
                        Math.pow(state.position.x - opponent.position.x, 2) +
                        Math.pow(state.position.y - opponent.position.y, 2) +
                        Math.pow(state.position.z - opponent.position.z, 2)
                    );
                    
                    if (distance < attackRange) {
                        opponent.health -= 5;
                        createAttackEffect(
                            new THREE.Vector3(opponent.position.x, opponent.position.y, opponent.position.z),
                            (playerNum === 1) ? 0xff0000 : 0x0000ff
                        );
                        
                        var dx = opponent.position.x - state.position.x;
                        var dz = opponent.position.z - state.position.z;
                        var len = Math.sqrt(dx * dx + dz * dz);
                        if (len > 0) {
                            opponent.velocity.x += (dx / len) * 0.6;
                            opponent.velocity.y += 0.3;
                            opponent.velocity.z += (dz / len) * 0.6;
                        }
                        
                        if (opponent.health <= 0) {
                            endGame((playerNum === 1) ? 'Red Fighter Wins!' : 'Blue Fighter Wins!');
                        }
                    }
                    attackCooldown[cooldown] = 30;
                }
            }
            
            function animate() {
                if (gameState.player1.health <= 0 || gameState.player2.health <= 0) {
                    if (renderer) renderer.render(scene, camera);
                    return;
                }
                
                animationId = requestAnimationFrame(animate);
                
                if (gameMode === 'local') {
                    processPlayerInput(1, keys);
                    processPlayerInput(2, keys);
                } else if (gameMode === 'bot') {
                    processPlayerInput(1, keys);
                    var botKeys = botAI();
                    processPlayerInput(2, botKeys);
                } else if (gameMode === 'online') {
                    if (isHost) {
                        processPlayerInput(1, keys);
                        sendGameState();
                    } else {
                        processPlayerInput(2, keys);
                        sendInput();
                    }
                }
                
                gameState.player1.velocity.y -= gravity;
                gameState.player2.velocity.y -= gravity;
                
                gameState.player1.position.x += gameState.player1.velocity.x;
                gameState.player1.position.y += gameState.player1.velocity.y;
                gameState.player1.position.z += gameState.player1.velocity.z;
                
                gameState.player2.position.x += gameState.player2.velocity.x;
                gameState.player2.position.y += gameState.player2.velocity.y;
                gameState.player2.position.z += gameState.player2.velocity.z;
                
                if (gameState.player1.position.y <= 1) {
                    gameState.player1.position.y = 1;
                    gameState.player1.velocity.y = 0;
                    gameState.player1.jumping = false;
                }
                if (gameState.player2.position.y <= 1) {
                    gameState.player2.position.y = 1;
                    gameState.player2.velocity.y = 0;
                    gameState.player2.jumping = false;
                }
                
                var maxPos = 5.5;
                gameState.player1.position.x = Math.max(-maxPos, Math.min(maxPos, gameState.player1.position.x));
                gameState.player1.position.z = Math.max(-maxPos, Math.min(maxPos, gameState.player1.position.z));
                gameState.player2.position.x = Math.max(-maxPos, Math.min(maxPos, gameState.player2.position.x));
                gameState.player2.position.z = Math.max(-maxPos, Math.min(maxPos, gameState.player2.position.z));
                
                if (attackCooldown.p1 > 0) attackCooldown.p1--;
                if (attackCooldown.p2 > 0) attackCooldown.p2--;
                
                updateVisuals();
                renderer.render(scene, camera);
            }
            
            function endGame(winnerText) {
                document.getElementById('winnerText').textContent = winnerText;
                document.getElementById('winnerScreen').classList.add('active');
                document.getElementById('hud').classList.remove('active');
                document.getElementById('controlsInfo').classList.remove('active');
            }
            
            function resetGame() {
                document.getElementById('winnerScreen').classList.remove('active');
                startGame(gameMode);
            }
            
            window.addEventListener('keydown', function(e) {
                keys[e.key.toLowerCase()] = true;
            });
            
            window.addEventListener('keyup', function(e) {
                keys[e.key.toLowerCase()] = false;
            });
            
            initThreeJS();
            
            return {
                showStartScreen: showStartScreen,
                showModeSelect: showModeSelect,
                showMultiplayerScreen: showMultiplayerScreen,
                startGame: startGame,
                connectToPeer: connectToPeer,
                resetGame: resetGame
            };
        })();
    </script>
</body>
</html>
