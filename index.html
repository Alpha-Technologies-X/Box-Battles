<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Box Battles</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
            position: absolute;
        }
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 10;
        }
        .screen.active {
            display: flex;
        }
        #startScreen {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        .title {
            font-size: 72px;
            font-weight: bold;
            text-shadow: 4px 4px 8px rgba(0,0,0,0.5);
            margin-bottom: 20px;
        }
        .subtitle {
            font-size: 24px;
            margin-bottom: 40px;
        }
        .btn {
            padding: 20px 60px;
            font-size: 28px;
            font-weight: bold;
            background: linear-gradient(45deg, #ff6b6b, #ee5a6f);
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            margin: 10px;
        }
        .btn:hover {
            transform: scale(1.1);
        }
        #multiplayerScreen {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }
        .peer-id-display {
            background: rgba(0,0,0,0.3);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            font-size: 24px;
            font-weight: bold;
        }
        .players-list {
            background: rgba(0,0,0,0.3);
            padding: 15px 30px;
            border-radius: 10px;
            margin: 20px 0;
            min-width: 300px;
        }
        .player-item {
            padding: 10px;
            margin: 5px 0;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
        }
        #hud {
            position: absolute;
            top: 20px;
            left: 0;
            right: 0;
            display: none;
            justify-content: space-around;
            padding: 0 40px;
            font-size: 18px;
            font-weight: bold;
            color: white;
            z-index: 5;
            flex-wrap: wrap;
        }
        #hud.active {
            display: flex;
        }
        .health-container {
            text-align: center;
            margin: 5px;
        }
        .health-bar-bg {
            background: #333;
            padding: 5px;
            border-radius: 5px;
            margin-top: 5px;
        }
        .health-bar {
            height: 12px;
            transition: width 0.3s;
        }
        #winnerScreen {
            background: rgba(0,0,0,0.9);
            color: white;
        }
        .winner-text {
            font-size: 48px;
            font-weight: bold;
            margin-bottom: 30px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="startScreen" class="screen active">
        <h1 class="title">BOX BATTLES</h1>
        <p class="subtitle">Fight inside the arena!</p>
        <button class="btn" onclick="game.showLocal()">PLAY LOCAL</button>
        <button class="btn" onclick="game.showMultiplayer()">ONLINE PARTY</button>
        <button class="btn" onclick="game.start('bot')">VS BOT</button>
    </div>
    
    <div id="multiplayerScreen" class="screen">
        <h1 class="title">ONLINE PARTY</h1>
        <div class="peer-id-display">
            Room Code: <span id="roomCode">...</span>
        </div>
        <div class="players-list">
            <div id="playersList"></div>
        </div>
        <input type="text" id="codeInput" placeholder="Enter Code" maxlength="8" style="padding: 15px; font-size: 20px; border-radius: 10px; margin: 10px;">
        <button class="btn" onclick="game.join()">JOIN</button>
        <button class="btn" id="startBtn" style="display:none;" onclick="game.startOnline()">START GAME</button>
        <button class="btn" onclick="game.showStart()">BACK</button>
    </div>
    
    <div id="hud"></div>
    
    <div id="winnerScreen" class="screen">
        <div class="winner-text" id="winnerText"></div>
        <button class="btn" onclick="game.reset()">PLAY AGAIN</button>
        <button class="btn" onclick="game.showStart()">MENU</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        var game = (function() {
            var scene, camera, renderer;
            var players = [];
            var gameMode = null;
            var peer, connections = [];
            var isHost = false;
            var myPlayerId = 0;
            var animationId = null;
            var roomCode = '';
            var playersInRoom = [];
            
            var playerColors = [0xff0000, 0x0000ff, 0x00ff00, 0xffff00];
            var playerNames = ['Red', 'Blue', 'Green', 'Yellow'];
            
            var gameState = {
                players: [
                    { health: 100, jumping: false, velocity: { x: 0, y: 0, z: 0 }, position: { x: -4, y: 1, z: 0 } },
                    { health: 100, jumping: false, velocity: { x: 0, y: 0, z: 0 }, position: { x: 4, y: 1, z: 0 } },
                    { health: 100, jumping: false, velocity: { x: 0, y: 0, z: 0 }, position: { x: -4, y: 1, z: 4 } },
                    { health: 100, jumping: false, velocity: { x: 0, y: 0, z: 0 }, position: { x: 4, y: 1, z: 4 } }
                ]
            };
            
            var keys = {};
            var moveSpeed = 0.15;
            var jumpPower = 0.3;
            var gravity = 0.015;
            var attackRange = 2.5;
            var attackCooldowns = [0, 0, 0, 0];
            
            function generateRoomCode() {
                var chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
                var code = '';
                for (var i = 0; i < 8; i++) {
                    code += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return code;
            }
            
            function initPeer() {
                roomCode = generateRoomCode();
                peer = new Peer(roomCode);
                
                peer.on('open', function(id) {
                    document.getElementById('roomCode').textContent = roomCode;
                    isHost = true;
                    myPlayerId = 0;
                    playersInRoom = [{ id: roomCode, name: 'Player 1 (You)' }];
                    updatePlayersList();
                    document.getElementById('startBtn').style.display = 'block';
                });
                
                peer.on('connection', function(conn) {
                    if (playersInRoom.length < 4) {
                        connections.push(conn);
                        setupConnection(conn);
                        var playerNum = playersInRoom.length + 1;
                        playersInRoom.push({ id: conn.peer, name: 'Player ' + playerNum });
                        updatePlayersList();
                        broadcastPlayersList();
                    }
                });
            }
            
            function join() {
                var code = document.getElementById('codeInput').value.trim().toUpperCase();
                if (code.length !== 8) {
                    alert('Room code must be 8 characters!');
                    return;
                }
                
                roomCode = code;
                peer = new Peer();
                
                peer.on('open', function(id) {
                    var conn = peer.connect(roomCode);
                    connections.push(conn);
                    setupConnection(conn);
                    isHost = false;
                });
            }
            
            function setupConnection(conn) {
                conn.on('open', function() {
                    if (!isHost) {
                        conn.send({ type: 'requestJoin' });
                    }
                });
                
                conn.on('data', function(data) {
                    if (data.type === 'requestJoin' && isHost) {
                        var newPlayerId = playersInRoom.length;
                        conn.send({ 
                            type: 'joinAccepted', 
                            playerId: newPlayerId,
                            players: playersInRoom
                        });
                    } else if (data.type === 'joinAccepted') {
                        myPlayerId = data.playerId;
                        playersInRoom = data.players;
                        playersInRoom[myPlayerId].name += ' (You)';
                        updatePlayersList();
                    } else if (data.type === 'playersList') {
                        playersInRoom = data.players;
                        updatePlayersList();
                    } else if (data.type === 'startGame') {
                        start('online');
                    } else if (data.type === 'gameState' && !isHost) {
                        gameState = data.state;
                        updateVisuals();
                    } else if (data.type === 'input' && isHost) {
                        processPlayerInput(data.playerId, data.keys);
                    }
                });
            }
            
            function broadcastPlayersList() {
                for (var i = 0; i < connections.length; i++) {
                    if (connections[i].open) {
                        connections[i].send({ type: 'playersList', players: playersInRoom });
                    }
                }
            }
            
            function updatePlayersList() {
                var html = '';
                for (var i = 0; i < playersInRoom.length; i++) {
                    html += '<div class="player-item">' + playersInRoom[i].name + '</div>';
                }
                document.getElementById('playersList').innerHTML = html;
            }
            
            function startOnline() {
                if (!isHost) return;
                
                for (var i = 0; i < connections.length; i++) {
                    if (connections[i].open) {
                        connections[i].send({ type: 'startGame' });
                    }
                }
                start('online');
            }
            
            function sendGameState() {
                if (!isHost) return;
                for (var i = 0; i < connections.length; i++) {
                    if (connections[i].open) {
                        connections[i].send({ type: 'gameState', state: gameState });
                    }
                }
            }
            
            function sendInput() {
                if (isHost || connections.length === 0) return;
                connections[0].send({ type: 'input', playerId: myPlayerId, keys: keys });
            }
            
            function showStart() {
                document.getElementById('startScreen').classList.add('active');
                document.getElementById('multiplayerScreen').classList.remove('active');
                document.getElementById('winnerScreen').classList.remove('active');
                document.getElementById('hud').classList.remove('active');
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
                if (peer) {
                    peer.destroy();
                    peer = null;
                }
                connections = [];
                playersInRoom = [];
            }
            
            function showLocal() {
                start('local');
            }
            
            function showMultiplayer() {
                document.getElementById('startScreen').classList.remove('active');
                document.getElementById('multiplayerScreen').classList.add('active');
                if (!peer) initPeer();
            }
            
            function initThreeJS() {
                var canvas = document.getElementById('gameCanvas');
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x87ceeb);
                
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 12, 18);
                camera.lookAt(0, 0, 0);
                
                renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                
                var ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);
                
                var directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 10, 5);
                directionalLight.castShadow = true;
                scene.add(directionalLight);
                
                var floorGeometry = new THREE.BoxGeometry(12, 0.5, 12);
                var floorMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
                var floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.position.y = -0.25;
                floor.receiveShadow = true;
                scene.add(floor);
                
                var wallMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x8b4513, 
                    transparent: true, 
                    opacity: 0.4,
                    side: THREE.DoubleSide
                });
                
                var backWall = new THREE.Mesh(new THREE.BoxGeometry(12, 6, 0.5), wallMaterial);
                backWall.position.set(0, 3, -6);
                scene.add(backWall);
                
                var frontWall = new THREE.Mesh(new THREE.BoxGeometry(12, 6, 0.5), wallMaterial);
                frontWall.position.set(0, 3, 6);
                scene.add(frontWall);
                
                var leftWall = new THREE.Mesh(new THREE.BoxGeometry(0.5, 6, 12), wallMaterial);
                leftWall.position.set(-6, 3, 0);
                scene.add(leftWall);
                
                var rightWall = new THREE.Mesh(new THREE.BoxGeometry(0.5, 6, 12), wallMaterial);
                rightWall.position.set(6, 3, 0);
                scene.add(rightWall);
                
                window.addEventListener('resize', function() {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
            
            function start(mode) {
                gameMode = mode;
                document.getElementById('startScreen').classList.remove('active');
                document.getElementById('multiplayerScreen').classList.remove('active');
                document.getElementById('hud').classList.add('active');
                
                var numPlayers = 2;
                if (mode === 'online') {
                    numPlayers = playersInRoom.length;
                }
                
                for (var i = 0; i < players.length; i++) {
                    scene.remove(players[i]);
                }
                players = [];
                
                for (var i = 0; i < numPlayers; i++) {
                    gameState.players[i].health = 100;
                    gameState.players[i].jumping = false;
                    gameState.players[i].velocity = { x: 0, y: 0, z: 0 };
                    attackCooldowns[i] = 0;
                    
                    var playerGeometry = new THREE.BoxGeometry(1, 2, 1);
                    var playerMaterial = new THREE.MeshStandardMaterial({ color: playerColors[i] });
                    var player = new THREE.Mesh(playerGeometry, playerMaterial);
                    player.castShadow = true;
                    players.push(player);
                    scene.add(player);
                }
                
                if (!renderer) {
                    initThreeJS();
                }
                
                updateHUD(numPlayers);
                updateVisuals();
                animate();
            }
            
            function updateHUD(numPlayers) {
                var html = '';
                for (var i = 0; i < numPlayers; i++) {
                    var colorHex = playerColors[i].toString(16).padStart(6, '0');
                    html += '<div class="health-container">';
                    html += '<div style="color:#' + colorHex + '">' + playerNames[i] + '</div>';
                    html += '<div class="health-bar-bg">';
                    html += '<div id="h' + i + '" class="health-bar" style="background:#' + colorHex + ';width:120px"></div>';
                    html += '</div></div>';
                }
                document.getElementById('hud').innerHTML = html;
            }
            
            function updateHealthBars() {
                for (var i = 0; i < players.length; i++) {
                    var elem = document.getElementById('h' + i);
                    if (elem) {
                        elem.style.width = (gameState.players[i].health * 1.2) + 'px';
                    }
                }
            }
            
            function updateVisuals() {
                for (var i = 0; i < players.length; i++) {
                    if (players[i]) {
                        players[i].position.set(
                            gameState.players[i].position.x, 
                            gameState.players[i].position.y, 
                            gameState.players[i].position.z
                        );
                    }
                }
                updateHealthBars();
            }
            
            function createAttackEffect(position, color) {
                var effect = new THREE.Mesh(
                    new THREE.SphereGeometry(0.5, 16, 16),
                    new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.7 })
                );
                effect.position.copy(position);
                scene.add(effect);
                
                setTimeout(function() {
                    scene.remove(effect);
                }, 200);
            }
            
            function botAI() {
                var botKeys = {};
                var p1Pos = gameState.players[0].position;
                var p2Pos = gameState.players[1].position;
                var distance = Math.sqrt(
                    Math.pow(p1Pos.x - p2Pos.x, 2) + 
                    Math.pow(p1Pos.z - p2Pos.z, 2)
                );
                
                if (distance > 3) {
                    if (p1Pos.x < p2Pos.x) {
                        botKeys['arrowleft'] = true;
                    } else {
                        botKeys['arrowright'] = true;
                    }
                    
                    if (p1Pos.z < p2Pos.z) {
                        botKeys['arrowup'] = true;
                    } else {
                        botKeys['arrowdown'] = true;
                    }
                }
                
                if (distance < attackRange && Math.random() > 0.95) {
                    botKeys['enter'] = true;
                }
                
                if (Math.random() > 0.98 && !gameState.players[1].jumping) {
                    botKeys['shift'] = true;
                }
                
                return botKeys;
            }
            
            function processPlayerInput(playerNum, inputKeys) {
                if (playerNum >= players.length) return;
                
                var state = gameState.players[playerNum];
                var controls;
                
                if (gameMode === 'online') {
                    controls = { up: 'w', down: 's', left: 'a', right: 'd', jump: 'q', attack: 'e' };
                    if (inputKeys['arrowup']) inputKeys['w'] = true;
                    if (inputKeys['arrowdown']) inputKeys['s'] = true;
                    if (inputKeys['arrowleft']) inputKeys['a'] = true;
                    if (inputKeys['arrowright']) inputKeys['d'] = true;
                    if (inputKeys['shift']) inputKeys['q'] = true;
                    if (inputKeys['enter']) inputKeys['e'] = true;
                } else {
                    controls = (playerNum === 0) ? 
                        { up: 'w', down: 's', left: 'a', right: 'd', jump: 'q', attack: 'e' } :
                        { up: 'arrowup', down: 'arrowdown', left: 'arrowleft', right: 'arrowright', jump: 'shift', attack: 'enter' };
                }
                
                if (inputKeys[controls.up]) {
                    state.velocity.z = -moveSpeed;
                } else if (inputKeys[controls.down]) {
                    state.velocity.z = moveSpeed;
                } else {
                    state.velocity.z = 0;
                }
                
                if (inputKeys[controls.left]) {
                    state.velocity.x = -moveSpeed;
                } else if (inputKeys[controls.right]) {
                    state.velocity.x = moveSpeed;
                } else {
                    state.velocity.x = 0;
                }
                
                if (inputKeys[controls.jump] && !state.jumping) {
                    state.velocity.y = jumpPower;
                    state.jumping = true;
                }
                
                if (inputKeys[controls.attack] && attackCooldowns[playerNum] <= 0) {
                    for (var i = 0; i < players.length; i++) {
                        if (i === playerNum) continue;
                        
                        var opponent = gameState.players[i];
                        var distance = Math.sqrt(
                            Math.pow(state.position.x - opponent.position.x, 2) +
                            Math.pow(state.position.y - opponent.position.y, 2) +
                            Math.pow(state.position.z - opponent.position.z, 2)
                        );
                        
                        if (distance < attackRange) {
                            opponent.health -= 5;
                            createAttackEffect(
                                new THREE.Vector3(opponent.position.x, opponent.position.y, opponent.position.z),
                                playerColors[playerNum]
                            );
                            
                            var dx = opponent.position.x - state.position.x;
                            var dz = opponent.position.z - state.position.z;
                            var len = Math.sqrt(dx * dx + dz * dz);
                            if (len > 0) {
                                opponent.velocity.x += (dx / len) * 0.6;
                                opponent.velocity.y += 0.3;
                                opponent.velocity.z += (dz / len) * 0.6;
                            }
                            
                            if (opponent.health <= 0) {
                                checkWinner();
                            }
                        }
                    }
                    attackCooldowns[playerNum] = 30;
                }
            }
            
            function checkWinner() {
                var alive = [];
                for (var i = 0; i < players.length; i++) {
                    if (gameState.players[i].health > 0) {
                        alive.push(i);
                    }
                }
                
                if (alive.length === 1) {
                    endGame(playerNames[alive[0]] + ' Wins!');
                } else if (alive.length === 0) {
                    endGame('Draw!');
                }
            }
            
            function animate() {
                var aliveCount = 0;
                for (var i = 0; i < players.length; i++) {
                    if (gameState.players[i].health > 0) {
                        aliveCount++;
                    }
                }
                
                if (aliveCount <= 1) {
                    if (renderer) renderer.render(scene, camera);
                    return;
                }
                
                animationId = requestAnimationFrame(animate);
                
                if (gameMode === 'local') {
                    processPlayerInput(0, keys);
                    processPlayerInput(1, keys);
                } else if (gameMode === 'bot') {
                    processPlayerInput(0, keys);
                    var botKeys = botAI();
                    processPlayerInput(1, botKeys);
                } else if (gameMode === 'online') {
                    if (isHost) {
                        processPlayerInput(myPlayerId, keys);
                        sendGameState();
                    } else {
                        processPlayerInput(myPlayerId, keys);
                        sendInput();
                    }
                }
                
                for (var i = 0; i < players.length; i++) {
                    gameState.players[i].velocity.y -= gravity;
                    
                    gameState.players[i].position.x += gameState.players[i].velocity.x;
                    gameState.players[i].position.y += gameState.players[i].velocity.y;
                    gameState.players[i].position.z += gameState.players[i].velocity.z;
                    
                    if (gameState.players[i].position.y <= 1) {
                        gameState.players[i].position.y = 1;
                        gameState.players[i].velocity.y = 0;
                        gameState.players[i].jumping = false;
                    }
                    
                    var maxPos = 5.5;
                    gameState.players[i].position.x = Math.max(-maxPos, Math.min(maxPos, gameState.players[i].position.x));
                    gameState.players[i].position.z = Math.max(-maxPos, Math.min(maxPos, gameState.players[i].position.z));
                    
                    if (attackCooldowns[i] > 0) attackCooldowns[i]--;
                }
                
                updateVisuals();
                renderer.render(scene, camera);
            }
            
            function endGame(winnerText) {
                document.getElementById('winnerText').textContent = winnerText;
                document.getElementById('winnerScreen').classList.add('active');
                document.getElementById('hud').classList.remove('active');
            }
            
            function reset() {
                document.getElementById('winnerScreen').classList.remove('active');
                start(gameMode);
            }
            
            window.addEventListener('keydown', function(e) {
                keys[e.key.toLowerCase()] = true;
            });
            
            window.addEventListener('keyup', function(e) {
                keys[e.key.toLowerCase()] = false;
            });
            
            initThreeJS();
            
            return {
                showStart: showStart,
                showLocal: showLocal,
                showMultiplayer: showMultiplayer,
                start: start,
                join: join,
                startOnline: startOnline,
                reset: reset
            };
        })();
    </script>
</body>
</html>
